{"title":"Muddy Points","markdown":{"yaml":{"title":"Muddy Points","subtitle":"Lesson","date-modified":"today","format":{"html":{"link-external-newwindow":true}},"editor_options":{"chunk_output_type":"console"}},"headingText":"Muddy points from Winter 2024","containsRefs":false,"markdown":"\n\n```{r}\n#| echo: false\n#| message: false\n\nlibrary(here)\n```\n\n### 1. More on the functions and problems we had in class!\n\n::: callout-important\nThis section has some examples from [this YouTube video series](https://www.youtube.com/watch?v=THGFXV4RW8U&list=PLiC1doDIe9rC8RgWPAWqDETE-VbKOWfWl&ab_channel=DataDaft). There is a video on mutate, pipe, filter, select, rename, arrange, and summarize. Note that some of the function in the series is outdated. The use of `if_else()` in the video is outdated, and it is more common to use `case_when()` now. The use of `gather` and `spread` have been replaced by `pivot_longer` and `pivot_wider`.\n:::\n\nTo discuss these functions below, I want to use a different dataset than what we used for examples in class. I'm hoping this allows us to see each function from a different angle. I'll use the dataset that we used for some of the `ggplot` examples: `mtcars`. Let's load the tidyverse and take a look at the dataset:\n\n```{r}\n#| message: false\n\nlibrary(tidyverse)\nglimpse(mtcars)\n```\n\n#### `mutate()`\n\nFor mutate, there are a few common uses:\n\n-   create another numeric variable by manipulating other variables\n\n-   create a categorical variable by creating cases from other variables\n\n##### Create another numeric variable by manipulating other variables\n\nThe `wt` variable is the weight of the car in tons. Let's say we want the full weight in pounds (lbs). I'll create a new variable that is 1000 times (1 ton = 1000 lbs) the weight in the dataset.\n\n```{r}\nmtcars1 = mtcars %>%\n  mutate(weight_lb = wt * 1000)\n\nglimpse(mtcars1)\n```\n\nWe can also perform several mutations at the same time. Let's say we want the weight in pounds AND the horse power per cylinder (`hp` per `cyl`). We can perform both manipulations:\n\n```{r}\nmtcars2 = mtcars %>%\n  mutate(weight_lb = wt * 1000, \n         hp_per_cyl = hp/cyl)\n\nglimpse(mtcars2)\n```\n\nYou can even use the same syntax if you need to change a variable that depends on a previous mutation. Let's say I want the ratio of weight in pounds to the car's horse power.\n\n```{r}\nmtcars3 = mtcars %>%\n  mutate(weight_lb = wt * 1000, \n         w_to_hp = weight_lb / hp)\n\nglimpse(mtcars3)\n```\n\n##### Create a categorical variable by creating cases from other variables\n\nRecall in class we used mutate to label the numeric values of `am` to a categorical variable `transmission`. We create a new categorical variable from a binary, numeric variable.\n\n```{r}\nmtcars4 = mtcars %>%\n  mutate(transmission = case_when(am == 0 ~ \"automatic\",\n                                  am == 1 ~ \"manual\"))\nglimpse(mtcars4)\n```\n\nWe can also create a categorical variable from a continuous numeric variable. Let's say we want to divide the miles per gallon into three categories: low, medium, and high. We can use `mutate()` and `case_when()` to do so:\n\n```{r}\nmtcars5 = mtcars %>%\n  mutate(mpg_cat = case_when(mpg > 22 ~ \"high\",\n                             mpg > 15 ~ \"medium\", \n                             .default = \"low\"))\nglimpse(mtcars5)\n```\n\nNotice that I used `.default` in the last case. This means \"for all other values of mpg, assign it to 'low'.\"\n\n#### pipe `%>%`\n\n[Check out the videos explanation!](https://www.youtube.com/watch?v=ui3VZeuN8QY&list=PLiC1doDIe9rC8RgWPAWqDETE-VbKOWfWl&index=2&ab_channel=DataDaft) I can't explain it much better!!\n\n#### `select()` everything but a certain variable\n\nIt seems like we're mostly okay with the `select()` function, but want more information on selecting everything but a certain varaible.\n\nWhen we select variables, we have the option to identify variables we want to keep or remove. If we want to keep a variable, we would just list the variable's column name. If we want to remove a variable, we use the minus sign to let R know that we do NOT want that variable. We typically do not tell R to remove and keep variables within the same `select()` function. Let's recall the variables within the original `mtcars` dataset:\n\n```{r}\nglimpse(mtcars)\n```\n\nNow we want to keep the following variables: `cyl`, `mpg`, `disp`, and `qsec`.\n\n```{r}\nmtcars6 = mtcars %>%\n  select(mpg, cyl, disp, qsec)\nglimpse(mtcars6)\n```\n\nIn this case there was less typing to ID the variables we wanted to keep, so we inputted the column names. If we wanted to ID the variables we wanted to remove, what variables would identify to get the same remaining variables that are in `mtcars6`?\n\nSo we want to remove the following variables:\n\n```{r}\nmtcars7 = mtcars %>%\n  select(-hp, -drat, -wt, -vs, -am, -gear, -carb)\nglimpse(mtcars7)\n```\n\nSo both get the job done, but one is definitely quicker to type!\n\n::: callout-note\n## We don't have to write the minus in front of every variable\n\nWhen we are removing several variables, we can combine them into a vector to remove:\n\n```{r}\nmtcars8 = mtcars %>%\n  select(-c(hp, drat, wt, vs, am, gear, carb))\nglimpse(mtcars8)\n\n```\n\nThe vector above is: `c(hp, drat, wt, vs, am, gear, carb)` and the minus sign in front of the vector will be applied to each variable.\n:::\n\n#### `pivot_longer()`\n\nI want to address the function with the faculty dataset from class.\n\n```{r}\n#| message: false\n\n# Note, I've put the data in a folder \"data\" that is in the same folder as this page's file\nstaff = read_csv(here(\"data/instructional-staff.csv\"))\nstaff\n```\n\nNote that I am not using `glimpse()` here because we only have 5 rows corresponding to the faculty type. What would a glimpse of the data look like?\n\n```{r}\nglimpse(staff)\n```\n\nBoth views are indicators that the dataset is in a \"wide\" format where each year has its own column. We want our data to be in a tidy format, which means each column is a variable and each cell has a value. However, the years are actually values for a variable \"year.\" By using `pivot_longer()`, we can tell R to take those columns for years and make them their own column where year is the value. That means for a year like 1975, there are five numbers corresponding to the five faculty types. Those five numbers are the percentage of the specific faculty type in that year. So we want to end with columns: faculty type, year, and percentage.\n\nTo start with an easier implementation of `pivot_longer()`, let's remove the faculty type using `select()`\n\n```{r}\nstaff2 = staff %>%\n  select(-faculty_type)\nstaff2\n```\n\nNow we can pivot the years! We first identify the columns that we want to pivot. To pivot all the columns, we say `cols = everything()`. `pivot_longer()` knows you want the column names to now become values of a variable, but it does not know what to call that variable. So now we identify the new variable name of the column that will contain all the years (our old column names). We identify the new variable name with: `names_to`. Finally, we need to adress the old cell values that were under each year in our wide dataset. Those cell values will make up a new column/variable. Remember that each year had 5 values underneath it, so we need to include all 55 cell values. Similar to `names_to`, we need to identify the new column names for all those values. We use `values_to` to identify the column name for the cell values of our old wide formatted data.\n\n```{r}\nstaff_long = staff2 %>%\n  pivot_longer(\n    cols = everything(),    # columns to pivot\n    names_to = \"year\",       # name of new column for variable names\n    values_to = \"percentage\" # name of new column for values\n  ) %>%\n  mutate(percentage = as.numeric(percentage))\n\nhead(staff_long, 20) # I'm asking R to show me the first 20 rows\n```\n\nI included the first 20 rows so we could see that the years repeat. This is because there were 5 percentages for each year. While this is in the desired long format, we now see that we're missing the information on faculty type. Each percentage in each year corresponded to a specific faculty type:\n\n```{r}\nstaff_long %>% filter(year == 1975)\n```\n\nWhich percentage is for which faculty??\n\nWe could use another function called `join()` to try to remedy the situation, but it's much easier to redo the pivot function. We will go back to `staff` which still has the faculty type:\n\n```{r}\nstaff\n```\n\nNow we can implement `pivot_longer()`. We will identify the columns we want to pivot as column 2 through 12 so we exclude the faculty type from the pivoting. BUT the really nice thing is that `pivot_longer()` will remember the percentages that correspond to a specific combination of faculty type and year! Let's try it again:\n\n```{r}\nstaff_long2 = staff %>%\n  pivot_longer(\n    cols = 2:12,    # columns to pivot\n    names_to = \"year\",       # name of new column for variable names\n    values_to = \"percentage\" # name of new column for values\n  ) %>%\n  mutate(percentage = as.numeric(percentage))\n\nhead(staff_long2, 20) # I'm asking R to show me the first 20 rows\n```\n\nAnd now I'll just dump a couple other ways to identify the columns we want to pivot:\n\n-   In this one, we name the column years. It's like 2:12, but it's helpful when it's hard to see what number the column is. Also, this is a special case because the columns are numbers, so we need to use ' to wrap around the year. In the `mtcars` dataset, a similar approach would be `cyl:vs` to select all the variables between `cyl` and `vs`. You can also make a vector of variable names if they are not next to each other.\n\n```{r}\nstaff_long3 = staff %>%\n  pivot_longer(\n    cols = '1975':'2011',    # columns to pivot\n    names_to = \"year\",       # name of new column for variable names\n    values_to = \"percentage\" # name of new column for values\n  ) %>%\n  mutate(percentage = as.numeric(percentage))\n\nhead(staff_long3, 20) # I'm asking R to show me the first 20 rows\n```\n\n-   This one is the same as our in-class code. We \"remove\" faculty type from our identified columns\n\n```{r}\nstaff_long4 = staff %>%\n  pivot_longer(\n    cols = -faculty_type,    # columns to pivot\n    names_to = \"year\",       # name of new column for variable names\n    values_to = \"percentage\" # name of new column for values\n  ) %>%\n  mutate(percentage = as.numeric(percentage))\n\nhead(staff_long4, 20) # I'm asking R to show me the first 20 rows\n```\n\n#### `across()`\n\nI really ran out of time before getting to this one. For now, you can look at the [examples from this site](https://dplyr.tidyverse.org/reference/across.html#ref-examples) to see the capabilities of `across()` . I invite you to try them out on the various datasets in our lecture.\n\n### 2. `tbl_summary()`: Trying to figure out how to change the median values to mean\n\nOh, wow! Turns out we solved it in class, but I made big mistake with my slides. The code for the table was in two places, but we fixed the one that was NOT running and showing on the slide!\n\nSo turns out, it worked!!\n\nHere's the code:\n\n```{r}\n#| message: false\n\nlibrary(tidyverse)  ## Need to load to use selec() and %>%\nlibrary(gtsummary)  ## Needed package for tbl_summary()\n\ndata(\"dds.discr\")\n\ndds.discr1 = dds.discr %>% \n  rename(SAB = gender, \n         R_E = ethnicity)\n\ndds.discr1 %>%\n  select(-id, -age.cohort) %>%\n  tbl_summary(label = c(age ~ \"Age\", \n                        R_E ~ \"Race/Ethnicity\", \n                        SAB ~ \"Sex Assigned at Birth\", \n                        expenditures ~ \"Expenditures\") ,\n              statistic = list(all_continuous() ~ \"{mean} ({sd})\"))\n```\n\n### 3. Are there benefits to ggplot compared to the base R graphing functions?\n\nThe main benefit I see for `ggplot` is that the syntax and grammar of our coding in `tidyr` and `dplyr` is very similar to `ggplot`. Your effort in strengthening one will help with the others.\n\nI am certainly not going to force you to use `ggplot` over base R. At the end of the day, it is really whatever makes the most sense to you. I will say: `ggplot2` seems to be where most statisticians and epidemiologists are headed. And I really believe that `ggplot` is more efficient with coding.\n\n","srcMarkdownNoYaml":"\n\n```{r}\n#| echo: false\n#| message: false\n\nlibrary(here)\n```\n### Muddy points from Winter 2024\n\n### 1. More on the functions and problems we had in class!\n\n::: callout-important\nThis section has some examples from [this YouTube video series](https://www.youtube.com/watch?v=THGFXV4RW8U&list=PLiC1doDIe9rC8RgWPAWqDETE-VbKOWfWl&ab_channel=DataDaft). There is a video on mutate, pipe, filter, select, rename, arrange, and summarize. Note that some of the function in the series is outdated. The use of `if_else()` in the video is outdated, and it is more common to use `case_when()` now. The use of `gather` and `spread` have been replaced by `pivot_longer` and `pivot_wider`.\n:::\n\nTo discuss these functions below, I want to use a different dataset than what we used for examples in class. I'm hoping this allows us to see each function from a different angle. I'll use the dataset that we used for some of the `ggplot` examples: `mtcars`. Let's load the tidyverse and take a look at the dataset:\n\n```{r}\n#| message: false\n\nlibrary(tidyverse)\nglimpse(mtcars)\n```\n\n#### `mutate()`\n\nFor mutate, there are a few common uses:\n\n-   create another numeric variable by manipulating other variables\n\n-   create a categorical variable by creating cases from other variables\n\n##### Create another numeric variable by manipulating other variables\n\nThe `wt` variable is the weight of the car in tons. Let's say we want the full weight in pounds (lbs). I'll create a new variable that is 1000 times (1 ton = 1000 lbs) the weight in the dataset.\n\n```{r}\nmtcars1 = mtcars %>%\n  mutate(weight_lb = wt * 1000)\n\nglimpse(mtcars1)\n```\n\nWe can also perform several mutations at the same time. Let's say we want the weight in pounds AND the horse power per cylinder (`hp` per `cyl`). We can perform both manipulations:\n\n```{r}\nmtcars2 = mtcars %>%\n  mutate(weight_lb = wt * 1000, \n         hp_per_cyl = hp/cyl)\n\nglimpse(mtcars2)\n```\n\nYou can even use the same syntax if you need to change a variable that depends on a previous mutation. Let's say I want the ratio of weight in pounds to the car's horse power.\n\n```{r}\nmtcars3 = mtcars %>%\n  mutate(weight_lb = wt * 1000, \n         w_to_hp = weight_lb / hp)\n\nglimpse(mtcars3)\n```\n\n##### Create a categorical variable by creating cases from other variables\n\nRecall in class we used mutate to label the numeric values of `am` to a categorical variable `transmission`. We create a new categorical variable from a binary, numeric variable.\n\n```{r}\nmtcars4 = mtcars %>%\n  mutate(transmission = case_when(am == 0 ~ \"automatic\",\n                                  am == 1 ~ \"manual\"))\nglimpse(mtcars4)\n```\n\nWe can also create a categorical variable from a continuous numeric variable. Let's say we want to divide the miles per gallon into three categories: low, medium, and high. We can use `mutate()` and `case_when()` to do so:\n\n```{r}\nmtcars5 = mtcars %>%\n  mutate(mpg_cat = case_when(mpg > 22 ~ \"high\",\n                             mpg > 15 ~ \"medium\", \n                             .default = \"low\"))\nglimpse(mtcars5)\n```\n\nNotice that I used `.default` in the last case. This means \"for all other values of mpg, assign it to 'low'.\"\n\n#### pipe `%>%`\n\n[Check out the videos explanation!](https://www.youtube.com/watch?v=ui3VZeuN8QY&list=PLiC1doDIe9rC8RgWPAWqDETE-VbKOWfWl&index=2&ab_channel=DataDaft) I can't explain it much better!!\n\n#### `select()` everything but a certain variable\n\nIt seems like we're mostly okay with the `select()` function, but want more information on selecting everything but a certain varaible.\n\nWhen we select variables, we have the option to identify variables we want to keep or remove. If we want to keep a variable, we would just list the variable's column name. If we want to remove a variable, we use the minus sign to let R know that we do NOT want that variable. We typically do not tell R to remove and keep variables within the same `select()` function. Let's recall the variables within the original `mtcars` dataset:\n\n```{r}\nglimpse(mtcars)\n```\n\nNow we want to keep the following variables: `cyl`, `mpg`, `disp`, and `qsec`.\n\n```{r}\nmtcars6 = mtcars %>%\n  select(mpg, cyl, disp, qsec)\nglimpse(mtcars6)\n```\n\nIn this case there was less typing to ID the variables we wanted to keep, so we inputted the column names. If we wanted to ID the variables we wanted to remove, what variables would identify to get the same remaining variables that are in `mtcars6`?\n\nSo we want to remove the following variables:\n\n```{r}\nmtcars7 = mtcars %>%\n  select(-hp, -drat, -wt, -vs, -am, -gear, -carb)\nglimpse(mtcars7)\n```\n\nSo both get the job done, but one is definitely quicker to type!\n\n::: callout-note\n## We don't have to write the minus in front of every variable\n\nWhen we are removing several variables, we can combine them into a vector to remove:\n\n```{r}\nmtcars8 = mtcars %>%\n  select(-c(hp, drat, wt, vs, am, gear, carb))\nglimpse(mtcars8)\n\n```\n\nThe vector above is: `c(hp, drat, wt, vs, am, gear, carb)` and the minus sign in front of the vector will be applied to each variable.\n:::\n\n#### `pivot_longer()`\n\nI want to address the function with the faculty dataset from class.\n\n```{r}\n#| message: false\n\n# Note, I've put the data in a folder \"data\" that is in the same folder as this page's file\nstaff = read_csv(here(\"data/instructional-staff.csv\"))\nstaff\n```\n\nNote that I am not using `glimpse()` here because we only have 5 rows corresponding to the faculty type. What would a glimpse of the data look like?\n\n```{r}\nglimpse(staff)\n```\n\nBoth views are indicators that the dataset is in a \"wide\" format where each year has its own column. We want our data to be in a tidy format, which means each column is a variable and each cell has a value. However, the years are actually values for a variable \"year.\" By using `pivot_longer()`, we can tell R to take those columns for years and make them their own column where year is the value. That means for a year like 1975, there are five numbers corresponding to the five faculty types. Those five numbers are the percentage of the specific faculty type in that year. So we want to end with columns: faculty type, year, and percentage.\n\nTo start with an easier implementation of `pivot_longer()`, let's remove the faculty type using `select()`\n\n```{r}\nstaff2 = staff %>%\n  select(-faculty_type)\nstaff2\n```\n\nNow we can pivot the years! We first identify the columns that we want to pivot. To pivot all the columns, we say `cols = everything()`. `pivot_longer()` knows you want the column names to now become values of a variable, but it does not know what to call that variable. So now we identify the new variable name of the column that will contain all the years (our old column names). We identify the new variable name with: `names_to`. Finally, we need to adress the old cell values that were under each year in our wide dataset. Those cell values will make up a new column/variable. Remember that each year had 5 values underneath it, so we need to include all 55 cell values. Similar to `names_to`, we need to identify the new column names for all those values. We use `values_to` to identify the column name for the cell values of our old wide formatted data.\n\n```{r}\nstaff_long = staff2 %>%\n  pivot_longer(\n    cols = everything(),    # columns to pivot\n    names_to = \"year\",       # name of new column for variable names\n    values_to = \"percentage\" # name of new column for values\n  ) %>%\n  mutate(percentage = as.numeric(percentage))\n\nhead(staff_long, 20) # I'm asking R to show me the first 20 rows\n```\n\nI included the first 20 rows so we could see that the years repeat. This is because there were 5 percentages for each year. While this is in the desired long format, we now see that we're missing the information on faculty type. Each percentage in each year corresponded to a specific faculty type:\n\n```{r}\nstaff_long %>% filter(year == 1975)\n```\n\nWhich percentage is for which faculty??\n\nWe could use another function called `join()` to try to remedy the situation, but it's much easier to redo the pivot function. We will go back to `staff` which still has the faculty type:\n\n```{r}\nstaff\n```\n\nNow we can implement `pivot_longer()`. We will identify the columns we want to pivot as column 2 through 12 so we exclude the faculty type from the pivoting. BUT the really nice thing is that `pivot_longer()` will remember the percentages that correspond to a specific combination of faculty type and year! Let's try it again:\n\n```{r}\nstaff_long2 = staff %>%\n  pivot_longer(\n    cols = 2:12,    # columns to pivot\n    names_to = \"year\",       # name of new column for variable names\n    values_to = \"percentage\" # name of new column for values\n  ) %>%\n  mutate(percentage = as.numeric(percentage))\n\nhead(staff_long2, 20) # I'm asking R to show me the first 20 rows\n```\n\nAnd now I'll just dump a couple other ways to identify the columns we want to pivot:\n\n-   In this one, we name the column years. It's like 2:12, but it's helpful when it's hard to see what number the column is. Also, this is a special case because the columns are numbers, so we need to use ' to wrap around the year. In the `mtcars` dataset, a similar approach would be `cyl:vs` to select all the variables between `cyl` and `vs`. You can also make a vector of variable names if they are not next to each other.\n\n```{r}\nstaff_long3 = staff %>%\n  pivot_longer(\n    cols = '1975':'2011',    # columns to pivot\n    names_to = \"year\",       # name of new column for variable names\n    values_to = \"percentage\" # name of new column for values\n  ) %>%\n  mutate(percentage = as.numeric(percentage))\n\nhead(staff_long3, 20) # I'm asking R to show me the first 20 rows\n```\n\n-   This one is the same as our in-class code. We \"remove\" faculty type from our identified columns\n\n```{r}\nstaff_long4 = staff %>%\n  pivot_longer(\n    cols = -faculty_type,    # columns to pivot\n    names_to = \"year\",       # name of new column for variable names\n    values_to = \"percentage\" # name of new column for values\n  ) %>%\n  mutate(percentage = as.numeric(percentage))\n\nhead(staff_long4, 20) # I'm asking R to show me the first 20 rows\n```\n\n#### `across()`\n\nI really ran out of time before getting to this one. For now, you can look at the [examples from this site](https://dplyr.tidyverse.org/reference/across.html#ref-examples) to see the capabilities of `across()` . I invite you to try them out on the various datasets in our lecture.\n\n### 2. `tbl_summary()`: Trying to figure out how to change the median values to mean\n\nOh, wow! Turns out we solved it in class, but I made big mistake with my slides. The code for the table was in two places, but we fixed the one that was NOT running and showing on the slide!\n\nSo turns out, it worked!!\n\nHere's the code:\n\n```{r}\n#| message: false\n\nlibrary(tidyverse)  ## Need to load to use selec() and %>%\nlibrary(gtsummary)  ## Needed package for tbl_summary()\n\ndata(\"dds.discr\")\n\ndds.discr1 = dds.discr %>% \n  rename(SAB = gender, \n         R_E = ethnicity)\n\ndds.discr1 %>%\n  select(-id, -age.cohort) %>%\n  tbl_summary(label = c(age ~ \"Age\", \n                        R_E ~ \"Race/Ethnicity\", \n                        SAB ~ \"Sex Assigned at Birth\", \n                        expenditures ~ \"Expenditures\") ,\n              statistic = list(all_continuous() ~ \"{mean} ({sd})\"))\n```\n\n### 3. Are there benefits to ggplot compared to the base R graphing functions?\n\nThe main benefit I see for `ggplot` is that the syntax and grammar of our coding in `tidyr` and `dplyr` is very similar to `ggplot`. Your effort in strengthening one will help with the others.\n\nI am certainly not going to force you to use `ggplot` over base R. At the end of the day, it is really whatever makes the most sense to you. I will say: `ggplot2` seems to be where most statisticians and epidemiologists are headed. And I really believe that `ggplot` is more efficient with coding.\n\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":"auto","echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":true,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","title-prefix":"","toc":true,"output-file":"02_Data_Management_muddy_points.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.8.25","theme":["../../sandstone_NW.scss"],"title":"Muddy Points","subtitle":"Lesson","date-modified":"today","editor_options":{"chunk_output_type":"console"}},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}